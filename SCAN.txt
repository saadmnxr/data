SCAN:
It is also called as Elevator Algorithm. In this algorithm, the disk arm moves into a
particular direction till the end, satisfying all the requests coming in its path, and then it
turns backend moves in the reverse direction satisfying requests coming in its path. It
works in the way an elevator works, elevator moves in a direction completely till the last
floor of that direction and then turns back.

Algorithm:
1. Let Request array represents an array storing indexes of tracks that have been
requested in ascending order of their time of arrival. ‘head’ is the position of disk head.
2. Let direction represents whether the head is moving towards left or right.
3. In the direction in which head is moving service all tracks one by one.
4. Calculate the absolute distance of the track from the head.
5. Increment the total seek count with this distance.
6. Currently serviced track position now becomes the new head position.
7. Go to step 3 until we reach at one of the ends of the disk.
8. If we reach at the end of the disk reverse the direction and go to step 2 until all tracks
in request array have not been serviced.


#include<stdio.h>
#include<stdlib.h>
int main()
{
 int RQ[100],i,j,n,TotalHeadMoment=0,initial,size,move;
 printf("Enter the number of Requests\n");
 scanf("%d",&n);
 printf("Enter the Requests sequence\n");
for(i=0;i<n;i++)
 scanf("%d",&RQ[i]);
 printf("Enter initial head position\n");
 scanf("%d",&initial);
 printf("Enter total disk size\n");
 scanf("%d",&size);
 printf("Enter the head movement direction for high 1 and for low 0\n");
 scanf("%d",&move);

 // logic for Scan disk scheduling

 /*logic for sort the request array */
 for(i=0;i<n;i++)
 {
 for(j=0;j<n-i-1;j++)
 {
 if(RQ[j]>RQ[j+1])
 {
 int temp;
 temp=RQ[j];
 RQ[j]=RQ[j+1];
 RQ[j+1]=temp;
 }
 }
 }
 int index;
 for(i=0;i<n;i++)
 {
if(initial<RQ[i])
 {
 index=i;
 break;
 }
 }

 // if movement is towards high value
 if(move==1)
 {
 for(i=index;i<n;i++)
 {
 TotalHeadMoment=TotalHeadMoment+abs(RQ[i]-initial);
 initial=RQ[i];
 }
 // last movement for max size
 TotalHeadMoment=TotalHeadMoment+abs(size-RQ[i-1]-1);
 initial = size-1;
 for(i=index-1;i>=0;i--)
 {
 TotalHeadMoment=TotalHeadMoment+abs(RQ[i]-initial);
 initial=RQ[i];

 }
 }
 // if movement is towards low value
 else
 {
 for(i=index-1;i>=0;i--)
 {
 TotalHeadMoment=TotalHeadMoment+abs(RQ[i]-initial);
 initial=RQ[i];
 }
 // last movement for min size
 TotalHeadMoment=TotalHeadMoment+abs(RQ[i+1]-0);
 initial =0;
 for(i=index;i<n;i++)
 {
 TotalHeadMoment=TotalHeadMoment+abs(RQ[i]-initial);
 initial=RQ[i];

 }
 }
 printf("Total head movement is %d",TotalHeadMoment);
 return 0;
}