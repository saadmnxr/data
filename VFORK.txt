Similar to fork(), vfork() creates a new subprocess for the calling process. However, vfork()
is specifically designed for subprocesses to execute exec() programs immediately.
#include <sys/types.h>
#include <unistd.h>
pid_t vfork(void); //Return: 0 in child process, child in parent process I Dï¼ŒThe error is-1
vfork() creates a child process just like fork(), but it does not copy the address space of the
parent process to the child process completely, because the child process will immediately
call exec (or exit), so the address space will not be accessed. However, before a child process
calls exec or exit, it runs in the space of the parent process. Another difference between
vfork() and fork() is that vfork() ensures that the child process runs first, and that the parent
process may not be scheduled until it calls exec or exit. (if the child process depends on
further actions of the parent process before these two functions are called, a deadlock can
result.)

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
#include<sys/wait.h>
#include<stdlib.h>
#include<errno.h>
#include<string.h>

 int main()
{
pid_t childPid;
 if((childPid=vfork())==-1)
 {
 printf("Fork error %s\n",strerror(errno));
 exit(1);
 }
 else
 if(childPid==0) //Subprocess
 {
 sleep(1); //Subprocess sleep for one second
 printf("I am the child : %d\n",getpid());
 exit(0);
 }
 else //Parent process
 {
 printf("I am the father : %d\n",getpid());
 exit(0);
 }
 /* switch(childPid=vfork()){
 case -1:
 printf("Fork error %s\n",strerror(errno));
 exit(1);
 case 0: //Subprocess
 sleep(1); //Subprocess sleep for one second
 printf("I am the child : %d\n",getpid());
 exit(0);
 default: //Parent process
 printf("I am the father : %d\n",getpid());
 exit(0);

 } */
 return 0;
}
